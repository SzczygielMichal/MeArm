/**
  ******************************************************************************
  * @file		init.c
  * @author		Przekaï¿½nik elektroniczny
  * @version	V1.0.0
  * @date		17.12.2014
  * @brief		This file contains the system clock configuration for STM32L1xx
  * 			High-density devices, and is generated by the Michaï¿½ Szczygieï¿½
  *             
  * 1.  This file provides two functions and one global variable to be called from 
  *     user application:
  *      - Init_RCC(): 
  *                        
  *      - Init_IO():
  *
  *      - Init_Peripherals():
  * 
  * 2. This file configures the system clock as follows:  
  *=============================================================================
  *                         System Clock Configuration
  *=============================================================================
  *        System Clock source          | PLL(HSE)
  *----------------------------------------------------------------------------- 
  *        SYSCLK                       | 32 MHz
  *----------------------------------------------------------------------------- 
  *        HCLK                         | 32 MHz
  *----------------------------------------------------------------------------- 
  *        AHB Prescaler                | 1
  *----------------------------------------------------------------------------- 
  *        APB1 Prescaler               | 1
  *----------------------------------------------------------------------------- 
  *        APB2 Prescaler               | 1
  *----------------------------------------------------------------------------- 
  *        HSE Frequency                | 4 MHz
  *----------------------------------------------------------------------------- 
  *        PLL DIV                      | 2
  *----------------------------------------------------------------------------- 
  *        PLL MUL                      | 16
  *----------------------------------------------------------------------------- 
  *        VDD                          | 3.3 V
  *----------------------------------------------------------------------------- 
  *        Vcore                        | 1.8 V (Range 1)
  *----------------------------------------------------------------------------- 
  *        Flash Latency                | 1 WS
  *----------------------------------------------------------------------------- 
  *        Require 48MHz for USB clock  | Enable
  *----------------------------------------------------------------------------- 
  *=============================================================================
  ******************************************************************************  
  */

#include <stdio.h>
#include "main.h"
#include "init.h"
#include "..\board\init.h"
#include "..\board\board_v_26_02_2017.h"
#include "stm32f10x.h"
#include "stm32f10x_gpio.h"
#include "..\setup\setup.h"
#include "..\StdPeriph_Driver\inc\misc.h"
#include "..\StdPeriph_Driver\inc\stm32f10x_adc.h"
#include "dbg_ctrl.h"

#include "../peripherals/timer/timer.h"
#include "../peripherals/uart/uart.h"

unsigned int i_nom, mull;
unsigned char i, tmp;

/**
 ******************************************************************************
  [..] RCC Referense Manual ST32F10x
 *
 *  @brief Init_RCC
 */
void Init_RCC(void)
{  
	/** W³¹czenie zasilania interfejsu zegara */
	SET_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);

	//  MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLMUL, RCC_CFGR_PLLMUL16);     // Mnoï¿½nik  /16	- Narazie moï¿½e zostaï¿½
	//  MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLDIV, RCC_CFGR_PLLDIV2);     // Dzielnik /2	- Narazie moï¿½e zostaï¿½
	MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLSRC, RCC_CFGR_PLLSRC_HSE);  // ï¿½rï¿½dï¿½o   HSE	- Narazie moï¿½e zostaï¿½
  
	//  SET_BIT(FLASH->ACR, FLASH_ACR_ACC64);                         // Wlaczenie obslugi 64bit odczytu flash
	//  SET_BIT(FLASH->ACR, FLASH_ACR_LATENCY | FLASH_ACR_PRFTEN);    // 1WaitState + Prefetch enabled

	/** W³¹cz Kwarc */
	SET_BIT(RCC->CR, RCC_CR_HSEON);
	while(!(RCC->CR & RCC_CR_HSERDY)){}

	/** W³¹cz PLL */
	SET_BIT(RCC->CR, RCC_CR_PLLON);
	while(!(RCC->CR & RCC_CR_PLLRDY)){}

	/** SYS_CLK 72 MHz*/ // - aktualne

	/** Prze³¹cz zegar systemowy na PLL */
	MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_CFGR_SW_PLL);
	while((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL){}       // Sprawdï¿½ czy PLL // do 3 taktï¿½w chyba

	MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE,  RCC_CFGR_HPRE_DIV1);    // AHB  /1  magistrala systemowa HCLK = 32MHz Systick = 4000
	MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_CFGR_PPRE1_DIV1);   // APB1 /1  magistrala peryferiï¿½w PCLK1 = 32MHz
	MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, RCC_CFGR_PPRE2_DIV1);   // APB2 /1  magistrala peryferiï¿½w PCLK2 = 32MHz
}

#if defined ( MEARM_BOARD_V_26_02_2017_H)

//
// \brief Platform Board 26.02.2017
//
void Init_IO(void)
{
//	PORT u¿yte w projekcie
//	PA0 - PA12, PA15,
//	PB0, PB1, PB3 - PB15
//	PC13 - PC15

//	PORT-A ----------------------------------------------------------------------------------------------------------
//	GPIO port A clock enable
	SET_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPAEN);

//	CRL
//	  0		PA0	-	ADC0	-	Pomiar wartoœci potencometru
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_MODE0, 0);	// ANALOG INPUT
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_CNF0, 0); 	// ANALOG INPUT
//	  1		PA1	-	ACD1	-	Pomiar wartoœci potencometru
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_MODE1, 0);	// ANALOG INPUT
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_CNF1, 0);	// ANALOG INPUT
//    2		PA2	-	ADC2	-	Pomiar wartoœci potencometru
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_MODE2, 0);	// ANALOG INPUT
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_CNF2, 0);	// ANALOG INPUT
//	  3		PA3	-	ADC3	-	Pomiar wartoœci potencometru
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_MODE3, 0);	// ANALOG INPUT
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_CNF3, 0);	// ANALOG INPUT
//	  4		PA4	-	ADC4	-	Pomiar wartoœci potencometru
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_MODE4, 0);	// ANALOG INPUT
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_CNF4, 0);	// ANALOG INPUT
//	  5		PA5	-	SPI_SCK	-	LED WS2812B
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_MODE5, GPIO_CRL_MODE5_0); // SPI1_SCK Output pin 10MHz
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_CNF5, GPIO_CRL_CNF5_1);	// Alternate function push-pull
//	  6		PA6	-	SPI_MISO-	LED WS2812B
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_MODE6, 0); // SPI1_MISO Input
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_CNF6, GPIO_CRL_CNF6_1);	// 	Input floating / Input pull-up
//	  7		PA7	-	SPI_MOSI-	LED WS2812B
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_MODE7, GPIO_CRL_MODE7_0); // SPI1_MOSI Output pin 10MHz
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_CNF7, GPIO_CRL_CNF7_1);	// Alternate function push-pull

//	CRH
//	  8		PA8		-	Nie u¿ywane
//	  9		PA9		-	USART1_TX
	MODIFY_REG(GPIOA->CRH, GPIO_CRH_MODE9, GPIO_CRH_MODE9_0)wejscie; // USART1_TX Output pin 10MHz
	MODIFY_REG(GPIOA->CRL, GPIO_CRH_CNF9, GPIO_CRH_CNF9_1);	// Alternate function push-pull
//	 10		PA10	-	USART1_RX
	MODIFY_REG(GPIOA->CRH, GPIO_CRH_MODE10, 0); // USART_RX Input pin
	MODIFY_REG(GPIOA->CRL, GPIO_CRH_CNF10, GPIO_CRH_CNF9_1);	// Input floating / Input pull-up
//	 11		PA11	-	USB_DM	-	Aktualnie nie u¿ywane
//	 12		PA12	-	USB_DP	-	Aktualnie nie u¿ywane
//	 13		PA13	-	Nie u¿ywane
//	 14		PA14	-	Nie u¿ywane
//	 15		PA15	-	Nie u¿ywane

//	 PORT-B ----------------------------------------------------------------------------------------------------------
//	GPIO port B clock enable
	SET_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPBEN);

//	CRL
//	  0   	PB0		-	TIM3	-	PWM Channel 3
	MODIFY_REG(GPIOB->CRL, GPIO_CRL_MODE0, GPIO_CRL_MODE0_0); // PWM Output pin 10MHz
	MODIFY_REG(GPIOB->CRL, GPIO_CRL_CNF0, GPIO_CRL_CNF0_1);	// Alternate function push-pull
//	  1		PB1		-	TIM3	-	PWM Channel 4
	MODIFY_REG(GPIOB->CRL, GPIO_CRL_MODE1, GPIO_CRL_MODE1_0); // PWM Output pin 10MHz
	MODIFY_REG(GPIOB->CRL, GPIO_CRL_CNF1, GPIO_CRL_CNF1_1);	// Alternate function push-pull
//    2		PB2		-	Nie u¿ywane
//	  3		PB3		-	Nie u¿ywane
//	  4		PB4		-	TIM3	-	PWM Channel 1
	MODIFY_REG(GPIOB->CRL, GPIO_CRL_MODE4, GPIO_CRL_MODE4_0); // PWM Output pin 10MHz
	MODIFY_REG(GPIOB->CRL, GPIO_CRL_CNF4, GPIO_CRL_CNF4_1);	// Alternate function push-pull
//	  5		PB5		-	TIM3	-	PWM Channel 0
	MODIFY_REG(GPIOB->CRL, GPIO_CRL_MODE5, GPIO_CRL_MODE5_0); // PWM Output pin 10MHz
	MODIFY_REG(GPIOB->CRL, GPIO_CRL_CNF5, GPIO_CRL_CNF5_1);	// Alternate function push-pull
//	  6
//	  7

	//	CRH
//	  8
//	  9
//	 10
//	 11
//	 12
	MODIFY_REG(GPIOB->CRH, GPIO_CRH_MODE12, GPIO_CRH_MODE12_0); // 10 Output pin 10MHz
//	 133
	MODIFY_REG(GPIOB->CRH, GPIO_CRH_MODE13, GPIO_CRH_MODE13_0); // 10 Output pin 10MHz
//	 14
	MODIFY_REG(GPIOB->CRH, GPIO_CRH_MODE14, GPIO_CRH_MODE14_0); // 10 Output pin 10MHz
//	 15
	MODIFY_REG(GPIOB->CRH, GPIO_CRH_MODE15, GPIO_CRH_MODE15_0); // 10 Output pin 10MHz

//	  12		PB12	-	SPI_NSS	-	LCD
	MODIFY_REG(GPIOA->CRL, GPIO_CRH_MODE12, GPIO_CRH_MODE12_0); // SP21_SCK Output pin 10MHz
	MODIFY_REG(GPIOA->CRL, GPIO_CRH_CNF12, GPIO_CRH_CNF12_1);	// Alternate function push-pull
//	  13		PB13	-	SPI_SCK	-	LCD
	MODIFY_REG(GPIOA->CRL, GPIO_CRH_MODE13, GPIO_CRH_MODE13_0); // SPI2_SCK Output pin 10MHz
	MODIFY_REG(GPIOA->CRL, GPIO_CRH_CNF13, GPIO_CRH_CNF13_1);	// Alternate function push-pull
//	  14		PA14		-	SPI_MISO-	LCD
	MODIFY_REG(GPIOA->CRL, GPIO_CRH_MODE14, 0); // SPI2_MISO Input
	MODIFY_REG(GPIOA->CRL, GPIO_CRH_CNF14, GPIO_CRH_CNF14_1);	// 	Input floating / Input pull-up
//	  15		PA15		-	SPI_MOSI-	LCD
	MODIFY_REG(GPIOA->CRL, GPIO_CRH_MODE15, GPIO_CRH_MODE15_0); // SPI2_MOSI Output pin 10MHz
	MODIFY_REG(GPIOA->CRL, GPIO_CRH_CNF15, GPIO_CRH_CNF15_1);	// Alternate function push-pull


//	 PORT-C ----------------------------------------------------------------------------------------------------------
//	!< GPIO port C clock enable
	SET_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPCEN);

//	CRH
//	 13
	MODIFY_REG(GPIOC->CRH, GPIO_CRH_MODE13, GPIO_CRH_MODE13_0); // 10 Output pin 10MHz
//	 14
	MODIFY_REG(GPIOC->CRH, GPIO_CRH_MODE14, GPIO_CRH_MODE14_0); // 10 Output pin 10MHz
//	 15
	MODIFY_REG(GPIOC->CRH, GPIO_CRH_MODE15, GPIO_CRH_MODE15_0); // 10 Output pin 10MHz

//     END GPIO ----------------------------------------------------------------------------------------------------------
}
#endif // Board


void Init_Peripherals(void)
{
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);

	Init_Timer();         // 1ms
	Init_LowSpeedTimer(); // 100ms
	Init_FastSpeedTimer();// 100us
   
//  Init_TIM5();

	InitUART1();          // Konsolka
  

	Init_ADC();
//  InitEXTI();

}

void StartUpReason(void)
{
//  unsigned int temp = RCC->CSR;
  
	sMeArm.statusS.startUpS.Entire = 0;

	if(RCC->CSR & RCC_CSR_LPWRRSTF)
	{
		sMeArm.statusS.startUpS.LowPowerReset = 1;
	}
	if(RCC->CSR & RCC_CSR_IWDGRSTF)
	{
		sMeArm.statusS.startUpS.IwdgReset = 1;
	}
	if(RCC->CSR & RCC_CSR_SFTRSTF)
	{
		sMeArm.statusS.startUpS.SoftReset = 1;
	}
	if(RCC->CSR & RCC_CSR_PORRSTF)
	{
		sMeArm.statusS.startUpS.PdrReset = 1;
	}
	if(RCC->CSR & RCC_CSR_PINRSTF)
	{
		sMeArm.statusS.startUpS.PinReset = 1;
	}

	TimerLowSpeedStart(eTimerLowSpeed_StartUp, 50);
}

unsigned char pot(unsigned int **tab, unsigned int pom)
{
	char i = 0;
	unsigned int min, max;

	do
	{
		max = (unsigned int)*tab;
		min = (unsigned int)*(tab+1);
		tab += 2;
		i++;
	}while(!((max > pom) && (min <= pom)));

	return i;
}

//void Init_Setup(void)
//{
//	unsigned char krok;
//	unsigned int pomiar;
//}
