/**
  ******************************************************************************
  * @file		init.c
  * @author		Przekaï¿½nik elektroniczny
  * @version	V1.0.0
  * @date		17.12.2014
  * @brief		This file contains the system clock configuration for STM32L1xx
  * 			High-density devices, and is generated by the Michaï¿½ Szczygieï¿½
  *             
  * 1.  This file provides two functions and one global variable to be called from 
  *     user application:
  *      - Init_RCC(): 
  *                        
  *      - Init_IO():
  *
  *      - Init_Peripherals():
  * 
  * 2. This file configures the system clock as follows:  
  *=============================================================================
  *                         System Clock Configuration
  *=============================================================================
  *        System Clock source          | PLL(HSE)
  *----------------------------------------------------------------------------- 
  *        SYSCLK                       | 32 MHz
  *----------------------------------------------------------------------------- 
  *        HCLK                         | 32 MHz
  *----------------------------------------------------------------------------- 
  *        AHB Prescaler                | 1
  *----------------------------------------------------------------------------- 
  *        APB1 Prescaler               | 1
  *----------------------------------------------------------------------------- 
  *        APB2 Prescaler               | 1
  *----------------------------------------------------------------------------- 
  *        HSE Frequency                | 4 MHz
  *----------------------------------------------------------------------------- 
  *        PLL DIV                      | 2
  *----------------------------------------------------------------------------- 
  *        PLL MUL                      | 16
  *----------------------------------------------------------------------------- 
  *        VDD                          | 3.3 V
  *----------------------------------------------------------------------------- 
  *        Vcore                        | 1.8 V (Range 1)
  *----------------------------------------------------------------------------- 
  *        Flash Latency                | 1 WS
  *----------------------------------------------------------------------------- 
  *        Require 48MHz for USB clock  | Enable
  *----------------------------------------------------------------------------- 
  *=============================================================================
  ******************************************************************************  
  */

#include <stdio.h>
#include "main.h"
#include "init.h"
#include "..\board\init.h"
#include "..\board\board_v_26_02_2017.h"
#include "stm32f10x.h"
#include "stm32f10x_gpio.h"
#include "..\setup\setup.h"
#include "..\StdPeriph_Driver\inc\misc.h"
#include "..\StdPeriph_Driver\inc\stm32f10x_adc.h"
#include "dbg_ctrl.h"
#include "../peripherals/timer/timer.h"
#include "../peripherals/uart/uart.h"

unsigned int i_nom, mull;
unsigned char i, tmp;

/**
 ******************************************************************************
  [..] RCC Referense Manual ST32F10x
 *
 *  @brief Init_RCC
 */
void Init_RCC(void)
{  
	/** W³¹czenie zasilania interfejsu zegara */
	SET_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);

	//  MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLMUL, RCC_CFGR_PLLMUL16);     // Mnoï¿½nik  /16	- Narazie moï¿½e zostaï¿½
	//  MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLDIV, RCC_CFGR_PLLDIV2);     // Dzielnik /2	- Narazie moï¿½e zostaï¿½
	MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLSRC, RCC_CFGR_PLLSRC_HSE);  // ï¿½rï¿½dï¿½o   HSE	- Narazie moï¿½e zostaï¿½
  
	//  SET_BIT(FLASH->ACR, FLASH_ACR_ACC64);                         // Wlaczenie obslugi 64bit odczytu flash
	//  SET_BIT(FLASH->ACR, FLASH_ACR_LATENCY | FLASH_ACR_PRFTEN);    // 1WaitState + Prefetch enabled

	/** W³¹cz Kwarc */
	SET_BIT(RCC->CR, RCC_CR_HSEON);
	while(!(RCC->CR & RCC_CR_HSERDY)){}

	/** W³¹cz PLL */
	SET_BIT(RCC->CR, RCC_CR_PLLON);
	while(!(RCC->CR & RCC_CR_PLLRDY)){}

	/** SYS_CLK 72 MHz*/ // - aktualne

	/** Prze³¹cz zegar systemowy na PLL */
	MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_CFGR_SW_PLL);
	while((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL){}       // Sprawdï¿½ czy PLL // do 3 taktï¿½w chyba

	MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE,  RCC_CFGR_HPRE_DIV1);    // AHB  /1  magistrala systemowa HCLK = 32MHz Systick = 4000
	MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_CFGR_PPRE1_DIV1);   // APB1 /1  magistrala peryferiï¿½w PCLK1 = 32MHz
	MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, RCC_CFGR_PPRE2_DIV1);   // APB2 /1  magistrala peryferiï¿½w PCLK2 = 32MHz
}

#if defined ( MEARM_BOARD_V_26_02_2017_H)

//
// \brief Platform Board 26.02.2017
//
void Init_IO(void)
{
//	PORT u¿yte w projekcie
//	PA0 - PA12, PA15,
//	PB0, PB1, PB3 - PB15
//	PC13 - PC15

//	 PORT-A ----------------------------------------------------------------------------------------------------------
//	!< GPIO port A clock enable
	SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIOAEN);

//	CRL
//	  0   Wyjœcie
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_MODE0, GPIO_CRL_MODE0_0); // 10 Output pin 10MHz
//	  1
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_MODE1, GPIO_CRL_MODE1_0); // 10 Output pin 10MHz
//    2
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_MODE2, GPIO_CRL_MODE2_0); // 10 Output pin 10MHz
//	  3
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_MODE3, GPIO_CRL_MODE3_0); // 10 Output pin 10MHz
//	  4
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_MODE4, GPIO_CRL_MODE4_0); // 10 Output pin 10MHz
//	  5
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_MODE5, GPIO_CRL_MODE5_0); // 10 Output pin 10MHz
//	  6
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_MODE6, GPIO_CRL_MODE6_0); // 10 Output pin 10MHz
//	  7
	MODIFY_REG(GPIOA->CRL, GPIO_CRL_MODE7, GPIO_CRL_MODE7_0); // 10 Output pin 10MHz

//	CRH
//	  8
	MODIFY_REG(GPIOA->CRH, GPIO_CRH_MODE8, GPIO_CRH_MODE8_0); // 10 Output pin 10MHz
//	  9
	MODIFY_REG(GPIOA->CRH, GPIO_CRH_MODE9, GPIO_CRH_MODE9_0); // 10 Output pin 10MHz
//	 10
	MODIFY_REG(GPIOA->CRH, GPIO_CRH_MODE10, GPIO_CRH_MODE10_0); // 10 Output pin 10MHz
//	 11
	MODIFY_REG(GPIOA->CRH, GPIO_CRH_MODE11, GPIO_CRH_MODE11_0); // 10 Output pin 10MHz
//	 12
	MODIFY_REG(GPIOA->CRH, GPIO_CRH_MODE12, GPIO_CRH_MODE12_0); // 10 Output pin 10MHz
//	 13
	MODIFY_REG(GPIOA->CRH, GPIO_CRH_MODE13, GPIO_CRH_MODE13_0); // 10 Output pin 10MHz
//	 14
	MODIFY_REG(GPIOA->CRH, GPIO_CRH_MODE14, GPIO_CRH_MODE14_0); // 10 Output pin 10MHz
//	 15
	MODIFY_REG(GPIOA->CRH, GPIO_CRH_MODE15, GPIO_CRH_MODE15_0); // 10 Output pin 10MHz


	//	 PORT-B ----------------------------------------------------------------------------------------------------------
	//	!< GPIO port B clock enable
		SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIOBEN);

	//	!< GPIOB.AFR[0]
	//	  0   Nie uï¿½ywane - wejcie
		MODIFY_REG(GPIOB->MODER,	GPIO_MODER_MODER2,	0); // 00 Input pin
	//	  1   Nie uï¿½ywane - wejcie
		MODIFY_REG(GPIOB->MODER,	GPIO_MODER_MODER2,	0); // 00 Input pin
	//    2   Nie uï¿½ywane
		MODIFY_REG(GPIOB->MODER,	GPIO_MODER_MODER2,	0); // 00 Input pin
	//	  3   Odczyt nastawy prï¿½du znamionowego - ADC5
		MODIFY_REG(GPIOB->MODER,    GPIO_MODER_MODER3,	GPIO_MODER_MODER3_1 | GPIO_MODER_MODER3_0); // 11 Analog pin
	//	  4   Zapis napiï¿½cia pomiarowego - DAC1
		MODIFY_REG(GPIOB->MODER,    GPIO_MODER_MODER4,	GPIO_MODER_MODER4_1 | GPIO_MODER_MODER4_0); // 11 Analog pin
	//	  5   Odczyt nastawy prï¿½du zwarciowego - ADC3
		MODIFY_REG(GPIOB->MODER,    GPIO_MODER_MODER5,	GPIO_MODER_MODER5_1 | GPIO_MODER_MODER5_0); // 11 Analog pin
	//	  6   Odczyt nastawy czasu wyzwalacza - ADC6
		MODIFY_REG(GPIOB->MODER,    GPIO_MODER_MODER6,	GPIO_MODER_MODER6_1 | GPIO_MODER_MODER6_0); // 11 Analog pin
	//	  7   GPIO - Wejscie uruchomienia odmierzania czasu
		MODIFY_REG(GPIOB->MODER,	GPIO_MODER_MODER7,	0); // 00 Input pin
	//	!< GPIOA.AFR[1]
	//	  8   GPIO - Wybï¿½r pomiaru wartoci prï¿½du
		MODIFY_REG(GPIOB->MODER,	GPIO_MODER_MODER8,	GPIO_MODER_MODER8_0); // 01 OUTPUT pin
	//	  9   TX_USART_1
		MODIFY_REG(GPIOB->MODER,    GPIO_MODER_MODER6,	GPIO_MODER_MODER6_1 | GPIO_MODER_MODER6_0); // 11 Analog pin
	//	 10   RX_USART_1
		MODIFY_REG(GPIOB->MODER,    GPIO_MODER_MODER6,	GPIO_MODER_MODER6_1 | GPIO_MODER_MODER6_0); // 11 Analog pin
	//	 11  USB - D- Uï¿½ywany do programowania
	//	 12  USB - D+ Uï¿½ywany do programowania
	//	 13 AF JTMS-SWDIO - bez zmian - To wymaga zastanowienia
	//	 14 AF JTCK-SWCLK - bez zmian - To wymaga zastanowienia
	//	 15 AF JTDI       - bez zmian
		MODIFY_REG(GPIOB->MODER,	GPIO_MODER_MODER8,	GPIO_MODER_MODER8_0); // 01 OUTPUT pin


//	 PORT-C ----------------------------------------------------------------------------------------------------------
//	!< GPIO port C clock enable
	SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIOCEN);

//	!< GPIOC.AFR[0]
//		PC_13	LED
	MODIFY_REG(GPIOC->MODER,    GPIO_MODER_MODER13,    GPIO_MODER_MODER13_0); // 01 OUTPUT pin

//		PC_14	GPIO - Przekaï¿½nik PK_2
	MODIFY_REG(GPIOC->MODER,    GPIO_MODER_MODER14,    GPIO_MODER_MODER14_0); // 01 OUTPUT pin

//		PC_15	GPIO - Przekaï¿½nik PK_4
	MODIFY_REG(GPIOC->MODER,    GPIO_MODER_MODER15,    GPIO_MODER_MODER15_0); // 01 OUTPUT pin

//     END GPIO ----------------------------------------------------------------------------------------------------------
}
#endif // Board


void Init_Peripherals(void)
{
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);

	Init_Timer();         // 1ms
	Init_LowSpeedTimer(); // 100ms
	Init_FastSpeedTimer();// 100us
   
//  Init_TIM5();

	InitUART1();          // Konsolka
  

//  Init_ADC();
//  InitEXTI();

}

void StartUpReason(void)
{
//  unsigned int temp = RCC->CSR;
  
	sMeArm.statusS.startUpS.Entire = 0;

	if(RCC->CSR & RCC_CSR_LPWRRSTF)
	{
		sMeArm.statusS.startUpS.LowPowerReset = 1;
	}
	if(RCC->CSR & RCC_CSR_IWDGRSTF)
	{
		sMeArm.statusS.startUpS.IwdgReset = 1;
	}
	if(RCC->CSR & RCC_CSR_SFTRSTF)
	{
		sMeArm.statusS.startUpS.SoftReset = 1;
	}
	if(RCC->CSR & RCC_CSR_PORRSTF)
	{
		sMeArm.statusS.startUpS.PdrReset = 1;
	}
	if(RCC->CSR & RCC_CSR_PINRSTF)
	{
		sMeArm.statusS.startUpS.PinReset = 1;
	}

	TimerLowSpeedStart(eTimerLowSpeed_StartUp, 50);
}

unsigned char pot(unsigned int **tab, unsigned int pom)
{
	char i = 0;
	unsigned int min, max;

	do
	{
		max = (unsigned int)*tab;
		min = (unsigned int)*(tab+1);
		tab += 2;
		i++;
	}while(!((max > pom) && (min <= pom)));

	return i;
}

//void Init_Setup(void)
//{
//	unsigned char krok;
//	unsigned int pomiar;
//}
